<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Women in Agriculture — Global South</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: #EDF6E0;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #2d3a1f;
      overflow: hidden;
    }
    .slide {
      width: 100vw; height: 100vh;
      display: grid;
      grid-template-columns: 280px 1fr;
      grid-template-rows: auto 1fr auto;
      padding: 16px 22px 10px;
      gap: 12px;
    }

    header {
      grid-column: 1 / -1;
      display: flex; align-items: center; justify-content: space-between;
    }
    .title-block h1 { font-size: 1.1rem; font-weight: 700; color: #1a2910; letter-spacing: -0.01em; line-height: 1.3; }
    .title-block p  { font-size: 0.85rem; color: #7a9455; margin-top: 2px; font-weight: 400; }

    /* LEFT PANEL */
    .left-panel {
      grid-column: 1;
      grid-row: 2;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: #d4e9b8;
      border-radius: 10px;
      padding: 16px;
      box-shadow: 0 2px 8px rgba(30,60,10,0.15);
    }

    .panel-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .panel-label {
      font-size: 0.75rem;
      font-weight: 700;
      color: #3a5820;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .toggle-group-vertical {
      display: flex;
      flex-direction: column;
      background: #b8d898;
      border-radius: 7px;
      padding: 4px;
      gap: 4px;
    }

    .toggle-btn {
      padding: 10px 16px;
      border: none;
      border-radius: 5px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      background: transparent;
      color: #556b3a;
      transition: all 0.15s;
      text-align: left;
    }
    .toggle-btn.active {
      background: #EDF6E0;
      color: #1a2910;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
    }

    .country-dropdown {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid #b8d898;
      border-radius: 6px;
      background: #EDF6E0;
      color: #1a2910;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }
    .country-dropdown:hover {
      border-color: #7a9455;
    }
    .country-dropdown:focus {
      outline: none;
      border-color: #556b3a;
    }

    /* MAP IN LEFT PANEL */
    .map-container {
      flex: 1;
      min-height: 0;
      background: #a8c98a;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    #map-canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    /* CHART AREA */
    .body {
      grid-column: 2;
      grid-row: 2;
      position: relative;
      min-height: 0;
      border-radius: 10px;
      overflow: hidden;
      background: #EDF6E0;
    }
    #chart-svg { display: block; width: 100%; height: 100%; }

    .source-bar {
      grid-column: 1 / -1;
      font-size: 0.7rem;
      color: #9ab87a;
      padding: 0 2px 2px;
    }

    .tooltip {
      position: fixed; background: #1a2910ee; color: #edf6e0;
      padding: 9px 14px; border-radius: 8px; font-size: 0.85rem;
      pointer-events: none; opacity: 0; transition: opacity 0.1s;
      line-height: 1.7; white-space: nowrap; z-index: 999;
    }
    .tooltip strong { display: block; font-size: 0.95rem; margin-bottom: 2px; }
  </style>
</head>
<body>
<div class="slide">
  <header>
    <div class="title-block">
      <h1>Women make a significant proportion of agricultural labour, but lack ownership of land titles and resources</h1>
      <p id="subtitle">Share of women employed in agriculture (in %)</p>
    </div>
  </header>

  <div class="left-panel">
    <div class="panel-section">
      <div class="toggle-group-vertical">
        <button class="toggle-btn active" data-metric="Employment">Agricultural Employment</button>
        <button class="toggle-btn" data-metric="Land Ownership">Agricultural Land Ownership</button>
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-label">Select Country</div>
      <select class="country-dropdown" id="country-select">
        <option value="">-- All Countries --</option>
      </select>
    </div>

    <div class="panel-section" style="flex: 1; min-height: 0;">
      <div class="panel-label">Map</div>
      <div class="map-container">
        <canvas id="map-canvas"></canvas>
      </div>
    </div>
  </div>

  <div class="body">
    <svg id="chart-svg"></svg>
  </div>

  <div class="source-bar">Source: ILO, FAO (UN) via Our World in Data</div>
</div>
<div class="tooltip" id="tooltip"></div>

<script>
/* ═══════════════ NAME MAPPING ═══════════════ */
function shpToDataset(n) { return n; }

const GLOBAL_SOUTH = new Set([
  "Algeria","American Samoa","Argentina","Bangladesh","Belize","Botswana","Brazil",
  "Burkina Faso","Cape Verde","Chile","Comoros","Cote d'Ivoire",
  "Democratic Republic of Congo","Dominican Republic","Ecuador","Egypt",
  "El Salvador","Ethiopia","Fiji","Gambia","Georgia","Guam","Guatemala",
  "Guinea","Haiti","India","Indonesia","Iran","Jamaica","Jordan","Kyrgyzstan",
  "Laos","Lebanon","Lesotho","Madagascar","Malawi","Malaysia","Mali","Mexico",
  "Morocco","Mozambique","Myanmar","Nepal","Nicaragua","Nigeria",
  "Northern Mariana Islands","Panama","Peru","Philippines","Puerto Rico",
  "Saint Kitts and Nevis","Saint Lucia","Samoa","Saudi Arabia","Senegal",
  "Seychelles","Sri Lanka","Tanzania","Thailand","Trinidad and Tobago",
  "Tunisia","Uganda","Uruguay","Venezuela","Vietnam","Zambia"
]);

// Show all countries, not just Global South
const SHOW_ALL_COUNTRIES = true;

/* ═══════════════ DATA ═══════════════ */
const RAW = [];
const dataByName = {};

/* ═══════════════ CHOROPLETH ═══════════════ */
const choroScale = d3.scaleSequential()
  .domain([0, 100])
  .interpolator(d3.interpolate('#f9e4b0', '#5b21b6'));

/* ═══════════════ STATE ═══════════════ */
let currentMetric = 'Employment';
let selectedCountry = 'India';
let geoData = null;
let mapZoomCountry = 'India';

/* Map animation state */
let currentScale = 1;
let currentOffX = 0;
let currentOffY = 0;
let targetScale = 1;
let targetOffX = 0;
let targetOffY = 0;
let animationProgress = 1; // 1 = complete, 0 = just started
let animationFrameId = null;

/* ═══════════════ TOOLTIP ═══════════════ */
const tipEl = document.getElementById('tooltip');
function showTip(ev, country, wPct) {
  tipEl.innerHTML = `<strong>${country}</strong>
    <span style="color:#c4a0ff">&#9632; Women: ${wPct.toFixed(1)}%</span>`;
  tipEl.style.opacity = '1';

  const viewportWidth = window.innerWidth;
  if (ev.clientX > viewportWidth / 2) {
    tipEl.style.left = (ev.clientX - tipEl.offsetWidth - 14) + 'px';
  } else {
    tipEl.style.left = (ev.clientX + 14) + 'px';
  }
  tipEl.style.top  = (ev.clientY - 12) + 'px';
}
function hideTip() { tipEl.style.opacity = '0'; }

/* ═══════════════ BUILD DATA ═══════════════ */
function buildData(metric) {
  const key = metric === 'Employment' ? 'em' : 'ow';
  return RAW
    .filter(d => d[key] !== null && d[key] !== undefined)
    .map(d => ({ country: d.c, women: d[key] }))
    .sort((a, b) => b.women - a.women);
}

/* ═══════════════ LOLLIPOP CHART ═══════════════ */
let chartInitialised = false;

function drawChart(metric, sel, animate) {
  const data  = buildData(metric);
  const svgEl = document.getElementById('chart-svg');
  const W = svgEl.clientWidth  || 900;
  const H = svgEl.clientHeight || 460;
  const margin = { top: 22, right: 14, bottom: 90, left: 30 };
  const iW = W - margin.left - margin.right;
  const iH = H - margin.top  - margin.bottom;

  const svg = d3.select('#chart-svg');
  const dur = animate ? 650 : 0;

  const paddingValue = metric === 'Employment' ? 0.25 : 0.12;
  const x = d3.scaleBand().domain(data.map(d => d.country)).range([0, iW]).padding(paddingValue);
  const y = d3.scaleLinear().domain([0, 100]).range([iH, 0]);
  const zero = y(0);
  const bw = x.bandwidth();

  if (!chartInitialised) {
    svg.selectAll('*').remove();
    chartInitialised = true;

    const g = svg.append('g').attr('class','chart-g')
      .attr('transform', `translate(${margin.left},${margin.top})`);

    [0,25,50,75,100].forEach(v => {
      g.append('line').attr('class','gridline')
        .attr('x1',0).attr('x2',iW).attr('y1',y(v)).attr('y2',y(v))
        .attr('stroke', v===0 ? '#4a6830' : '#c4dba0')
        .attr('stroke-width', v===0 ? 1.5 : 0.6)
        .attr('stroke-dasharray', v===0 ? null : '3,3');
    });

    g.append('g').attr('class','lollipops-layer');
    g.append('g').attr('class','xlabels-layer');
    g.append('g').attr('class','sellabels-layer');
  }

  const g           = svg.select('.chart-g');
  const lollipopsLayer = g.select('.lollipops-layer');
  const xlabsLayer  = g.select('.xlabels-layer');
  const sellabLayer = g.select('.sellabels-layer');
  const hasSel      = sel !== null;

  /* WOMEN LOLLIPOPS */
  lollipopsLayer.selectAll('.stem-w')
    .data(data, d => d.country)
    .join(
      enter => enter.append('line').attr('class','stem-w')
        .attr('x1', d => x(d.country) + bw/2)
        .attr('x2', d => x(d.country) + bw/2)
        .attr('y1', zero).attr('y2', zero)
        .style('cursor','pointer')
        .on('mousemove', (ev,d) => showTip(ev, d.country, d.women))
        .on('mouseleave', hideTip)
        .on('click', (_,d) => handleSelect(d.country))
    )
    .on('mousemove', (ev,d) => showTip(ev, d.country, d.women))
    .on('mouseleave', hideTip)
    .on('click', (_,d) => handleSelect(d.country))
    .attr('stroke', d => (!hasSel || sel===d.country) ? '#7c3aed' : '#c4b0e828')
    .attr('stroke-width', d => {
      const baseWidth = metric === 'Employment' ? 2.5 : 3.5;
      const fadedWidth = metric === 'Employment' ? 1.5 : 2;
      return (!hasSel || sel===d.country) ? baseWidth : fadedWidth;
    })
    .transition().duration(dur).ease(d3.easeCubicInOut)
      .attr('x1', d => x(d.country) + bw/2)
      .attr('x2', d => x(d.country) + bw/2)
      .attr('y1', zero)
      .attr('y2', d => y(d.women));

  lollipopsLayer.selectAll('.circle-w')
    .data(data, d => d.country)
    .join(
      enter => enter.append('circle').attr('class','circle-w')
        .attr('cx', d => x(d.country) + bw/2)
        .attr('cy', zero)
        .attr('r', 0)
        .style('cursor','pointer')
        .on('mousemove', (ev,d) => showTip(ev, d.country, d.women))
        .on('mouseleave', hideTip)
        .on('click', (_,d) => handleSelect(d.country))
    )
    .on('mousemove', (ev,d) => showTip(ev, d.country, d.women))
    .on('mouseleave', hideTip)
    .on('click', (_,d) => handleSelect(d.country))
    .attr('fill', d => (!hasSel || sel===d.country) ? '#7c3aed' : '#c4b0e828')
    .transition().duration(dur).ease(d3.easeCubicInOut)
      .attr('cx', d => x(d.country) + bw/2)
      .attr('cy', d => y(d.women))
      .attr('r', d => {
        const baseRadius = metric === 'Employment' ? 5.5 : 6.5;
        const fadedRadius = metric === 'Employment' ? 3.5 : 4.5;
        return (!hasSel || sel===d.country) ? baseRadius : fadedRadius;
      });


  /* LABELS */
  sellabLayer.selectAll('*').remove();
  if (sel) {
    const sd = data.find(d => d.country === sel);
    if (sd) {
      const bx = x(sd.country) + bw / 2;
      sellabLayer.append('text').attr('class','sel-label')
        .attr('x', bx).attr('y', y(sd.women) - 10)
        .attr('text-anchor','middle')
        .attr('font-size','12px').attr('font-weight','700').attr('fill','#5b21b6')
        .text(sd.women.toFixed(1) + '%');
    }
  }

  xlabsLayer.selectAll('.xlabel')
    .data(data, d => d.country)
    .join(
      enter => enter.append('text').attr('class','xlabel')
        .attr('text-anchor', hasSel ? 'middle' : 'end')
        .attr('y', hasSel ? iH + 15 : iH + 5)
        .attr('x', d => x(d.country) + bw/2)
        .attr('transform', d => {
          const cx = x(d.country) + bw/2;
          return hasSel ? '' : `rotate(270,${cx},${iH+5})`;
        })
        .attr('opacity', 0)
    )
    .attr('font-size', d => {
      if (metric === 'Employment') {
        return sel===d.country ? '9px' : '7.5px';
      } else {
        return sel===d.country ? '11px' : '9.5px';
      }
    })
    .attr('fill',       d => sel===d.country ? '#1a2910' : '#556b3a')
    .attr('font-weight',d => sel===d.country ? '700' : '500')
    .transition().duration(dur).ease(d3.easeCubicInOut)
      .attr('text-anchor', hasSel ? 'middle' : 'end')
      .attr('y', hasSel ? iH + 15 : iH + 5)
      .attr('opacity', d => {
        if (hasSel) {
          return sel === d.country ? 1 : 0;
        } else {
          return 1;
        }
      })
      .attr('x', d => x(d.country) + bw/2)
      .attr('transform', d => {
        const cx = x(d.country) + bw/2;
        return hasSel ? '' : `rotate(270,${cx},${iH+5})`;
      })
      .text(d => d.country);
}

/* ═══════════════ MAP WITH ZOOM ═══════════════ */
const mapCanvas = document.getElementById('map-canvas');
const mapCtx = mapCanvas.getContext('2d');
let MAP_W, MAP_H, baseScale, baseOffX, baseOffY;
let hoveredCountry = null;

/* Get country bounding box */
function getCountryBounds(countryName) {
  if (!geoData) return null;

  const feature = geoData.features.find(f => shpToDataset(f.properties.NAME_LONG) === countryName);
  if (!feature || !feature.geometry) return null;

  const polys = feature.geometry.type === 'Polygon' ? [feature.geometry.coordinates] : feature.geometry.coordinates;

  let minLon = Infinity, maxLon = -Infinity;
  let minLat = Infinity, maxLat = -Infinity;

  polys.forEach(poly => {
    poly.forEach(ring => {
      ring.forEach(([lon, lat]) => {
        minLon = Math.min(minLon, lon);
        maxLon = Math.max(maxLon, lon);
        minLat = Math.min(minLat, lat);
        maxLat = Math.max(maxLat, lat);
      });
    });
  });

  return { minLon, maxLon, minLat, maxLat };
}

function initMapCanvas() {
  const container = mapCanvas.parentElement;
  const r = container.getBoundingClientRect();
  MAP_W = r.width;
  MAP_H = r.height;
  mapCanvas.width = MAP_W * devicePixelRatio;
  mapCanvas.height = MAP_H * devicePixelRatio;
  mapCtx.scale(devicePixelRatio, devicePixelRatio);

  calculateMapProjection();
}

function calculateMapProjection(animate = false) {
  const pad = 8;
  let lonMin, lonMax, latMin, latMax;

  if (mapZoomCountry) {
    const bounds = getCountryBounds(mapZoomCountry);
    if (bounds) {
      const lonPad = (bounds.maxLon - bounds.minLon) * 0.6;
      const latPad = (bounds.maxLat - bounds.minLat) * 0.6;
      lonMin = bounds.minLon - lonPad;
      lonMax = bounds.maxLon + lonPad;
      latMin = bounds.minLat - latPad;
      latMax = bounds.maxLat + latPad;
    } else {
      // Fallback to Global South
      lonMin = -118; lonMax = 141; latMin = -56; latMax = 44;
    }
  } else {
    // Global South bbox - always show this when no country selected
    lonMin = -118; lonMax = 141; latMin = -56; latMax = 44;
  }

  const lonRange = lonMax - lonMin;
  const latRange = latMax - latMin;
  const regionAspect = lonRange / latRange;
  const canvasAspect = MAP_W / MAP_H;

  let newScale, newOffX, newOffY;

  if (canvasAspect > regionAspect) {
    newScale = (MAP_H - 2*pad) / (latRange / 180);
    newOffX = (MAP_W - newScale * (lonRange / 180)) / 2;
    newOffY = pad;
  } else {
    newScale = (MAP_W - 2*pad) / (lonRange / 180);
    newOffX = pad;
    newOffY = (MAP_H - newScale * (latRange / 180)) / 2;
  }

  const unitLonMin = (lonMin + 180) / 360;
  const unitLatMax = (90 - latMax) / 180;
  newOffX -= unitLonMin * newScale * 2;
  newOffY -= unitLatMax * newScale;

  if (animate && animationProgress >= 1) {
    // Start new animation
    targetScale = newScale;
    targetOffX = newOffX;
    targetOffY = newOffY;
    animationProgress = 0;

    if (!animationFrameId) {
      animateMapZoom();
    }
  } else {
    // Immediate update (no animation)
    baseScale = newScale;
    baseOffX = newOffX;
    baseOffY = newOffY;
    currentScale = newScale;
    currentOffX = newOffX;
    currentOffY = newOffY;
    targetScale = newScale;
    targetOffX = newOffX;
    targetOffY = newOffY;
  }
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function animateMapZoom() {
  const duration = 800; // ms
  const fps = 60;
  const increment = 1000 / (fps * duration);

  function animate() {
    animationProgress += increment;

    if (animationProgress >= 1) {
      animationProgress = 1;
      baseScale = targetScale;
      baseOffX = targetOffX;
      baseOffY = targetOffY;
      currentScale = targetScale;
      currentOffX = targetOffX;
      currentOffY = targetOffY;
      animationFrameId = null;
      drawMap(currentMetric, selectedCountry);
      return;
    }

    const eased = easeInOutCubic(animationProgress);
    baseScale = currentScale + (targetScale - currentScale) * eased;
    baseOffX = currentOffX + (targetOffX - currentOffX) * eased;
    baseOffY = currentOffY + (targetOffY - currentOffY) * eased;

    drawMap(currentMetric, selectedCountry);
    animationFrameId = requestAnimationFrame(animate);
  }

  animationFrameId = requestAnimationFrame(animate);
}

function lonLatToUnit(lon, lat) {
  return [(lon + 180) / 360, (90 - lat) / 180];
}

function unitToScreen(ux, uy) {
  return [baseOffX + ux * baseScale * 2, baseOffY + uy * baseScale];
}

function drawMap(metric, sel) {
  if (!geoData) return;
  const key = metric === 'Employment' ? 'em' : 'ow';

  mapCtx.clearRect(0, 0, MAP_W, MAP_H);
  mapCtx.fillStyle = '#a8c98a';
  mapCtx.fillRect(0, 0, MAP_W, MAP_H);

  geoData.features.forEach(feat => {
    const geom = feat.geometry;
    if (!geom) return;

    const dname = shpToDataset(feat.properties.NAME_LONG);
    const isGS = GLOBAL_SOUTH.has(dname);
    const row = dataByName[dname];
    const val = row ? row[key] : null;

    const polys = geom.type === 'Polygon' ? [geom.coordinates] : geom.coordinates;

    mapCtx.beginPath();
    polys.forEach(poly => {
      poly.forEach(ring => {
        ring.forEach(([lon, lat], j) => {
          const [sx, sy] = unitToScreen(...lonLatToUnit(lon, lat));
          j === 0 ? mapCtx.moveTo(sx, sy) : mapCtx.lineTo(sx, sy);
        });
        mapCtx.closePath();
      });
    });

    if (dname === sel) {
      mapCtx.fillStyle = '#facc15';
    } else if (dname === hoveredCountry) {
      mapCtx.fillStyle = '#fdee88';
    } else if (!isGS) {
      mapCtx.fillStyle = '#d0e8b0';
    } else if (val === null) {
      mapCtx.fillStyle = '#bdd89a';
    } else {
      mapCtx.fillStyle = choroScale(val);
    }
    mapCtx.fill();

    mapCtx.strokeStyle = dname === sel ? '#1a2910' : '#7aaa55';
    mapCtx.lineWidth = dname === sel ? 1.2 : 0.4;
    mapCtx.stroke();
  });
}

function hitTestMap(mx, my) {
  const sx = mx, sy = my;
  const ux = (sx - baseOffX) / (baseScale * 2);
  const uy = (sy - baseOffY) / baseScale;
  const lon = ux * 360 - 180;
  const lat = 90 - uy * 180;

  for (let i = geoData.features.length - 1; i >= 0; i--) {
    const feat = geoData.features[i];
    const geom = feat.geometry;
    if (!geom) continue;
    const polys = geom.type === 'Polygon' ? [geom.coordinates] : geom.coordinates;
    for (const poly of polys) {
      for (const ring of poly) {
        if (pointInRing(lon, lat, ring)) {
          return shpToDataset(feat.properties.NAME_LONG);
        }
      }
    }
  }
  return null;
}

function pointInRing(px, py, ring) {
  let inside = false;
  for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
    const xi = ring[i][0], yi = ring[i][1];
    const xj = ring[j][0], yj = ring[j][1];
    if (((yi > py) !== (yj > py)) && px < (xj - xi) * (py - yi) / (yj - yi) + xi)
      inside = !inside;
  }
  return inside;
}

/* Map events */
mapCanvas.addEventListener('mousemove', ev => {
  const r = mapCanvas.getBoundingClientRect();
  const mx = ev.clientX - r.left;
  const my = ev.clientY - r.top;
  const country = hitTestMap(mx, my);

  if (country !== hoveredCountry) {
    hoveredCountry = country;
    drawMap(currentMetric, selectedCountry);
  }

  if (country) {
    const key = currentMetric === 'Employment' ? 'em' : 'ow';
    const row = dataByName[country];
    if (row && row[key] !== null) {
      showTip(ev, country, row[key]);
    } else {
      hideTip();
    }
  } else {
    hideTip();
  }
});

mapCanvas.addEventListener('mouseleave', () => {
  hoveredCountry = null;
  hideTip();
  drawMap(currentMetric, selectedCountry);
});

mapCanvas.addEventListener('click', ev => {
  const r = mapCanvas.getBoundingClientRect();
  const mx = ev.clientX - r.left;
  const my = ev.clientY - r.top;
  const country = hitTestMap(mx, my);

  if (country) {
    const key = currentMetric === 'Employment' ? 'em' : 'ow';
    const row = dataByName[country];
    if (row && row[key] !== null) {
      handleSelect(country);
    }
  }
});

/* ═══════════════ INTERACTION ═══════════════ */
function handleSelect(country) {
  selectedCountry = selectedCountry === country ? null : country;

  // Update dropdown
  const dropdown = document.getElementById('country-select');
  dropdown.value = selectedCountry || '';

  // Update map zoom with animation
  mapZoomCountry = selectedCountry;
  calculateMapProjection(true); // animate = true

  drawChart(currentMetric, selectedCountry, false);
  // drawMap will be called by animation, or immediately if no animation
  if (animationProgress >= 1) {
    drawMap(currentMetric, selectedCountry);
  }
}

/* ═══════════════ CONTROLS ═══════════════ */
const SUBTITLES = {
  Employment: 'Share of women employed in agriculture (in %)',
  'Land Ownership':  'Share of women in agriculture who own land solely or jointly with a member of household (in %)',
};

// Metric toggle
document.querySelectorAll('.toggle-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentMetric = btn.dataset.metric;
    document.getElementById('subtitle').textContent = SUBTITLES[currentMetric];

    if (selectedCountry) {
      const key = currentMetric === 'Employment' ? 'em' : 'ow';
      const row = dataByName[selectedCountry];
      if (!row || row[key] === null || row[key] === undefined) {
        selectedCountry = null;
        mapZoomCountry = null;
        document.getElementById('country-select').value = '';
        calculateMapProjection(true); // animate zoom out
      }
    }
    drawChart(currentMetric, selectedCountry, true);
    if (animationProgress >= 1) {
      drawMap(currentMetric, selectedCountry);
    }
  });
});

// Country dropdown
document.getElementById('country-select').addEventListener('change', (ev) => {
  const country = ev.target.value;
  if (country) {
    selectedCountry = country;
    mapZoomCountry = country;
  } else {
    selectedCountry = null;
    mapZoomCountry = null;
  }

  calculateMapProjection(true); // animate = true
  drawChart(currentMetric, selectedCountry, false);
  if (animationProgress >= 1) {
    drawMap(currentMetric, selectedCountry);
  }
});

/* ═══════════════ INIT ═══════════════ */
Promise.all([
  d3.json('world_simple.geojson?v=' + Date.now()),
  d3.csv('employment_final.csv?v=' + Date.now()),
  d3.csv('landown-final.csv?v=' + Date.now())
])
  .then(([geoJson, employmentData, landownData]) => {
    geoData = geoJson;

    // Load employment data - all countries
    employmentData.forEach(row => {
      const country = row.Entity;
      if (!SHOW_ALL_COUNTRIES && !GLOBAL_SOUTH.has(country)) return;

      const femaleEmp = parseFloat(row['Female employment in agriculture']);
      if (isNaN(femaleEmp)) return;

      RAW.push({ c: country, em: femaleEmp, ow: null });
    });

    // Load land ownership data - all countries
    landownData.forEach(row => {
      const country = row.Entity;
      if (!SHOW_ALL_COUNTRIES && !GLOBAL_SOUTH.has(country)) return;

      const femaleOwn = parseFloat(row['female-landowners']);
      if (isNaN(femaleOwn)) return;

      const existing = RAW.find(r => r.c === country);
      if (existing) {
        existing.ow = femaleOwn;
      } else {
        RAW.push({ c: country, em: null, ow: femaleOwn });
      }
    });

    RAW.forEach(d => dataByName[d.c] = d);

    // Populate dropdown with countries that have data for current metric
    const dropdown = document.getElementById('country-select');
    const countries = buildData(currentMetric).map(d => d.country).sort();
    countries.forEach(country => {
      const option = document.createElement('option');
      option.value = country;
      option.textContent = country;
      dropdown.appendChild(option);
    });

    // Set India as default selected in dropdown
    dropdown.value = 'India';

    initMapCanvas();
    drawChart(currentMetric, selectedCountry, false);
    drawMap(currentMetric, selectedCountry);
  })
  .catch(err => console.error('Data load error:', err));

window.addEventListener('resize', () => {
  chartInitialised = false;
  initMapCanvas();
  drawChart(currentMetric, selectedCountry, false);
  drawMap(currentMetric, selectedCountry);
});
</script>
</body>
</html>
